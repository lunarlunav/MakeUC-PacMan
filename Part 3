 private void initLevel() {
	init i:
	for (i = 0; i< N_BLOCKS; i++0 {
		screenData[i] = levelData[i];
	}
 }


 private void playGame(Graphics2D g2d) {
	if (dying) {
	    death();
	} else {
		movePacman();
		drawPacman(g2d);
		moveGhosts(g2d);
		checkMaze();
	}
 }

 public void movePacman()
	int pos;
	short ch;

	if (pacman_X % BLOCK_SIZE == 0 && pacman_y % BLOCK_SIZE == 0) {
	    pos = pacman_x / BLOCK_SIZE + N_BLOCKS * (int) (pacman_y / BLOCK_SIZE)
		  ch = screenData[pos];
	    if ((ch & 16 ) !=0){
	       screenData[pos] = (short) (ch & 15);
	       score++;
	    }
	    if (req_dq_!=0 || req_dy!= 0 ) {
	        if (!((req_dx == -1 && req_dy == 0 && (ch & 1) != 0)
		|| (req_dy == 1 && req_dy 0 && (ch & 4) != 0)
		|| (req_dx == 0 && req_dy -1 && (ch & 2) != 0)
		|| (req_dx == 0 && req_dy 1 && (ch & 8) != 0))) {
		    pacmand_x | = req_dx;
		    pacmand_y | = req_dy;
		}
	     }
	   
	     if (( pacmand_x == -1 && 0 && (ch & 1) != 0)
	     || (pacmand_x == 1 && pacman_y == 0 && (ch & 4) !+ 0)
	     || (pacman_x == 0 && pacman_y == -1 && (ch & 2) != 0)
	     || (pacman_x == 0 && pacman_y == 1 && (ch & 8) != 0)){
	 	pacman_x == 0;
		pacman_y == 0;
	      }
	}

	pacman_x = pacman_x + PACMAN_SPEED * pacmand_x;
	pacman_y = pacman_y + PACMAN_SPEED * pacmand_y;


   }

  public void drawPacman(Graphics2d (g2d) {
	if (req_dx == -1) {
	    g2d.drawImage(left, pacman_x +1,pacman_y +1,this);
	}else if (req_dx == 1){
	    g2d.drawImage(right, pacman_x +1,pacman_y +1,this);
	}else if (req_dy == -1){
	    g2d.drawImage(up, pacman_x +1,pacman_y +1,this);
	}else {
	    g2d.drawImage(down, pacman_x +1,pacman_y +1,this);
	}
  }

  public void moveGhosts(Graphics2d g2d) {
	int pos;
	int count;
	for (int i = 0;i < N_GHOSTS; i++) {
	    if (ghost_x[i] % BLOCK_SIZE == 0 && ghost_y[i] % BLOCK_SIZE == 0) {
		pos= ghost_x[i] / BLOCK_SIZE + N_BLOCKS * (int) (ghost_y[i] / BLOCK_SIZE);

		count = 0;
		if ((screenData[pos] & 1 ) == 0 && ghost_dx[1] != 1 ) {
		     dx[count] = -1;
		     dy[count] = 0;
		      count++;


		if ((screenData[pos] & 2 ) == 0 && ghost_dx[1] != 1 ) {
		     dx[count] = 0;
		     dy[count] = -1;
		      count++;

		if ((screenData[pos] & 4 ) == 0 && ghost_dx[1] != -1 ) {
		     dx[count] = 1;
		     dy[count] = 0;
		      count++;

		if ((screenData[pos] & 8 ) == 0 && ghost_dx[1] != -1 ) {
		     dx[count] = 0;
		     dy[count] = 1;
		      count++;
		}

	if (count = 0) {
		if ((screenData[pos] & 15 ) = 15) {
		   ghost_dy[i] =0;
		   ghost_dx[i] =0;
		}else {
		   ghost_dy[i] = -ghost_dy[i];
		   ghost_dx[i] = =ghost_dx[1];
		}
	} else {
		count = (int) (Math.random() * count);

	        if (count>3) {
		   count = 3;
		}
		
		ghost_dx[i] = dx[count];
		ghost_dy[i] = dy[count];
	
		}
	}

	ghost_x[i] = ghost_x[i] + (ghost_dx[i] * ghostSpeed[i]);
	ghost_y[i] = ghost_y[i] + (ghost_dy[i] * ghostSpeed[i]);
	drawGhost(g2d, ghost_x[i] + 1, ghost_y[i] +1);

	if (pacman_x > (ghost_x[i] -12) && pacman_x < (ghost_x[i] +12 )
	&& pacman_y > (ghost_y[i] -12 && pacman_y < (ghost_y[i] +12)
	&& inGame) {
	dying = true;
      }

     }
  }

  Public void drawGhost(Graphics2D g2d, int x, int y) {
} 



 private  void continueLevel() {
	int dx = l;
	int random;

	for (int i = O; i< N_GHOSTS; i++) {
	ghost_y[i] = 4* BLOCK_SIZE;
	ghost_x[i] = 4 * BLOCK_SIZE;
	ghost_dy[i] = 0;
	ghost_dx = dx;
	dx = -dx;
	random - 
